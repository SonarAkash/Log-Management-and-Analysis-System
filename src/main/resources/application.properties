spring.application.name=LogManager
#spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration

# Wal properties
wal.max-size=200000

# This path points to a directory on the server where the application will run, not inside the project folder
# for now in development phase I am writing it here.
wal.active-wal-path=test/wal/activeWal.log
# src/main/resources/WAL/activeWal.log
# src/main/resources/WAL/ArchivedWal
wal.archived-wal-directory-path=test/wal/archivedWal


# ===============================================================
# DATABASE CONNECTION (PostgreSQL running in Docker)
# ===============================================================

# The JDBC URL for your PostgreSQL container
# jdbc:postgresql://<host>:<port>/<database-name>
spring.datasource.url=jdbc:postgresql://localhost:5432/log_management

# The username and password you defined in docker-compose.yml
spring.datasource.username=Akash_Sonar
spring.datasource.password=Akash@3119

# The specific driver for PostgreSQL
spring.datasource.driver-class-name=org.postgresql.Driver

# ===============================================================
# JPA & HIBERNATE CONFIGURATION
# ===============================================================

# We set this to 'validate' because we are managing the schema ourselves with our SQL script.
# 'validate' makes Hibernate check if the tables and columns match the @Entity classes on startup.
# NEVER use 'create' or 'create-drop' in a real application with persistent data.
spring.jpa.hibernate.ddl-auto=validate

# Specifies the specific SQL "language" Hibernate should use for PostgreSQL
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect



# DEBUGGING
#logging.level.org.springframework.security=DEBUG

# Secret key
#secure.key=NDg1MTQyYjUtYWNiZS00ZDIzLTg5YjItN2RlZmFkMDIxZmEzNDg1MTQyYjUtYWNiZS00ZDIzLTg5YjItN2RlZmFkMDIxZmEz
secure.key=NWUgZGUgZDcgODcgMjcgZTUgMDEgMzQgZjYgOTggZjAgZTkgMmIgYTIgYjMgMzkgCjYzIGUyIDI1IDFiIGY1IDU5IDc4IGRkIDhkIGQwIGJhIDg0IDIwIDFkIDRlIGQ3IAo0ZiA3MiBmNyBlOSAyYSA2YiA3YiAyOCBmNSA2NiA5ZiA1NiBlNiA1ZiAzYSAyNyA=



# ======== BUCKET4J RATE LIMITING CONFIGURATION ========

# Enable the rate limiting filter
bucket4j.enabled=true


# The URL pattern this rule applies to. '^' means starts with.
bucket4j.filters[0].url=^/api/v1/ingest.*

# How to handle requests that exceed the limit.
# 'REJECT' will immediately return an HTTP 429 Too Many Requests.
bucket4j.filters[0].strategy=REJECT

# The HTTP status code to return when rejected.
bucket4j.filters[0].http-status-code=429

# --- Define the actual rate limit for this rule ---

# This creates a "bucket" with a capacity of 1000 tokens.
bucket4j.filters[0].rate-limit.bandwidths[0].capacity=1000

# This specifies that 1000 tokens are refilled over a period of 1 minute.
bucket4j.filters[0].rate-limit.bandwidths[0].time=1
bucket4j.filters[0].rate-limit.bandwidths[0].unit=minutes

